<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Initialization

InitDLLs();
D3DModelCreateWirecube();
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///T File Storage

TFileDir = "";

//Files
FDAT = noone;
ITEM = noone;
MO   = noone;
RTIM = noone;
RTMD = noone;
TALK = noone;
VAB  = noone;
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Find Game Installation

GameName = "";
GameVersion = -1;
lMapFiles = ds_list_create();

GameIdentify();


</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Load T Files for game

switch(GameVersion)
{
    case KFVersion.KFIIJpRev0:
        FDAT = TFileOpen(TFileDir + "FDAT.T");
        ITEM = noone;
        MO   = TFileOpen(TFileDir + "MO.T");
        RTIM = TFileOpen(TFileDir + "RTIM.T");
        RTMD = TFileOpen(TFileDir + "RTMD.T");
        TALK = noone;
        VAB  = noone;
        
        GenMapNameKFIIJpRev0(lMapFiles);
        
        rtimFdat = RTIMLoad(FDAT, 47);
        GameName = "KFII";
    break;
    
    case KFVersion.KFIIIJpRev0:
        FDAT  = TFileOpen(TFileDir + "FDAT.T");
        ITEM  = noone;
        MO    = TFileOpen(TFileDir + "MO.T");
        MOF   = TFileOpen(TFileDir + "MOF.T");
        RTIM  = TFileOpen(TFileDir + "RTIM.T");
        RTMD  = TFileOpen(TFileDir + "RTMD.T");
        STALK = noone;
        TALK  = noone;
        VAB   = noone;    
        
        GenMapNameKFIIIJpRev0(lMapFiles);
        
        rtimFdat = RTIMLoad(FDAT, 96);
        GameName = "KFIII";
    break;
    
    case KFVersion.KFIIIPilotStyle:
        FDAT  = TFileOpen(TFileDir + "FDAT.T");
        ITEM  = noone;
        MO    = TFileOpen(TFileDir + "MO.T");
        MOF   = TFileOpen(TFileDir + "MOF.T");
        RTIM  = TFileOpen(TFileDir + "RTIM.T");
        RTMD  = TFileOpen(TFileDir + "RTMD.T");
        STALK = noone;
        TALK  = noone;
        VAB   = noone;    
        
        GenMapNameKFIIIPilotStyle(lMapFiles);
        
        rtimFdat = RTIMLoad(FDAT, 96);
        GameName = "KFIII Pilot Style";   
    break;
    
    default:
        show_error("How did I get here?..", false);
        break;
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Setup Map Data

mapLoadID = -1;

map1Data = noone;
map2Data = noone;
map3Data = noone;
rtmdData = noone;
rtimData = noone;

rtimFromTrigger = noone;

chunkedMapDataO = ds_grid_create(8, 8);
chunkedMapDataT = ds_grid_create(8, 8);

psxVRAM = -1;
psxVRAMTex = -1;

moModelMap = array_create(1000);

///Clear MOModelMap to -1
for(var k = 0; k &lt; 1000; ++k)
    moModelMap[k] = -1;


currentRTMDid = -1;
currentRTIMid = -1;

dataReady = false;

triggerState = array_create(256);
for(var k = 0; k &lt; 256; ++k)
    triggerState[k] = false;
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Set up Minimap surface

minimapSize = 80;
minimapSurf = surface_create(minimapSize, minimapSize);
renderMiniMap = false;

surface_set_target(minimapSurf)
draw_clear(c_black);
surface_reset_target();
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Setup MapView surface

mapviewW = 960 - 266;
mapviewH = 540 - 4;

mapviewSurf = surface_create(mapviewW, mapviewH);

surface_set_target(mapviewSurf);
    draw_clear(c_black);
surface_reset_target();
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Camera Data

xFrom = 0;
yFrom = 0;
zFrom = -20000;
yRot = 0;
xRot = 0;

camSpeed = 512;

lastMouseX = 0;
lastMouseY = 0;

fullscreen = false;
drawObjIDs = false;
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Scroll Bar

scrollMapVOff = 0;
scrollMapVNum = 17;
scrollMapVLim = 17;
scrollScrubVPos = 0;
scrollScrubHeld = false;

MOFOffset = 0;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Handle UI Mouse Event

//Map Selection
if(mouse_check_button_pressed(mb_left) &amp;&amp; !fullscreen)
{
    //
    // Map Selection
    //
    var DXP, DYP, DWS, DHS;
    
    for(var i = scrollMapVOff; i &lt; scrollMapVNum; ++i)
    {     
        //Calculate Positions
        DXP = 2;
        DYP = 4 + (16 * (i - scrollMapVOff));
        DWS = DXP + 230;
        DHS = DYP + 15;
        
        //Is mouse intersecting with one of the maps? 
        if(point_in_rectangle(mouse_x, mouse_y, DXP, DYP, DWS, DHS))
        {   
            if(i == mapLoadID)
                continue;
 
            mapLoadID = i;
            event_perform(ev_other, ev_user0);
            break;
        }    
    }
}

//Scroll
var ScrollActive = ds_list_size(lMapFiles) &gt; scrollMapVLim;

if(mouse_check_button_pressed(mb_left) &amp;&amp; !fullscreen)
{    
    if(ScrollActive)
    {
        //First check if mouse is in bounds of the scroll par
        var ScrollPos = (4 + 16) + scrollScrubVPos;
    
        if(point_in_rectangle(mouse_x, mouse_y, 243, ScrollPos-16, 261, ScrollPos+16))       
            scrollScrubHeld = true;
    }
}else
if(mouse_check_button_released(mb_left))
{
    if(ScrollActive)
    {
        scrollScrubHeld = false;
    }
}

if(scrollScrubHeld &amp;&amp; ScrollActive)
{
    //Calculate scroll mouse pos
    var CMX = clamp((mouse_x-16) - 243, 0, 18);
    var CMY = clamp((mouse_y-16) - 4, 0, 242);
    
    //Calcualte max pages
    var pageCount = ds_list_size(lMapFiles) - scrollMapVLim;
    
    scrollMapVOff = floor(clamp((pageCount / 242) * CMY, 0, pageCount));
    scrollScrubVPos = (242 / pageCount) * scrollMapVOff;
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Handle UI Keyboard Event

if(keyboard_check_pressed(ord("F")))
    fullscreen = !fullscreen;
    
if(keyboard_check_pressed(ord("O")))
    drawObjIDs = !drawObjIDs;    

if(keyboard_check_pressed(ord("E")) &amp;&amp; dataReady)
{
    show_debug_message("Beginning Map Export");
    
    //
    // TEXTURE EXPORT...
    //
    show_debug_message("Exporting Textures...");
    
    //FDAT Texture
    RTIMSave(rtimFdat, GameName+"\"+MapName+"\texture_00.png");
    RTIMSave(rtimData, GameName+"\"+MapName+"\texture_01.png");
    
    //Trigger Texture... Kinda hacky and wrong + bloat
    var tList = map2Data[4], tInst = noone, rtimTemp;
    var valid = 0;
    for(var i = 0; i &lt; ds_list_size(tList); ++i)
    {
        //Get trigger from list
        tInst = tList[| i];
        
        //Skip if this trigger has an invalid RTIM
        if(tInst[15] &lt; 8 || tInst[15] == $FF)
            continue;
        
        //Load RTIM, Save RTIM then Free    
        rtimTemp = RTIMLoad(RTIM, tInst[15]);        
        RTIMSave(rtimTemp, GameName+"\"+MapName+"\texture_"+numPad(2+valid, "0", 2)+".png");        
        RTIMFree(rtimTemp);
        
        valid++;
    }
    
    //
    // TILE EXPORT
    //
    show_debug_message("Exporting tiles...");
    
    RTMDSave(rtmdData, GameName+"\"+MapName+"\Tiles\");
    
    //
    // TILEMAP EXPORT (TXT Coordinates)
    //
    show_debug_message("Exporting tilemap...");
    var TileMap = map1Data[0];

    var File = file_text_open_write(GameName+"\"+MapName+"\tilemap.txt");
    for(var yy = 0; yy &lt; 80; ++yy)
    {
        for(var xx = 0; xx &lt; 80; ++xx)
        {
            var Tile = TileMap[xx, yy];
            
            if(Tile[0] &lt; ds_list_size(rtmdData))
            {
                //Layer 1
                file_text_write_string(File, string(Tile[0]) + " ");
                file_text_write_string(File, "2 ");
                file_text_write_real(File, -$14000 + (2048 * xx));
                file_text_write_real(File, (Tile[1] * -$80));
                file_text_write_real(File, -$14000 + (2048 * yy));
                file_text_write_real(File, ((3 - Tile[2]) * 90) - 90);
            }
            
            if(Tile[5] &lt; ds_list_size(rtmdData))
            {
                //Layer 2
                file_text_write_string(File, string(Tile[5]) + " ");
                file_text_write_string(File, "1 ");
                file_text_write_real(File, -$14000 + (2048 * xx));
                file_text_write_real(File, (Tile[6] * -$80));
                file_text_write_real(File, -$14000 + (2048 * yy));
                file_text_write_real(File, ((3 - Tile[7]) * 90) - 90);
            }
        }
    }
    file_text_close(File);
    
    //
    // CHUNK EXPORT
    //
    show_debug_message("Exporting chunks...");    
    SaveMapVBs();
    
    
    show_message_async("Done! :)");  
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Handle Camera Movement

if(mouse_check_button_pressed(mb_right))
{
    lastMouseX = window_mouse_get_x();
    lastMouseY = window_mouse_get_y(); 
}

if(dataReady == true &amp;&amp; mouse_check_button(mb_right))
{
    //Mouse Input (Camera)
    xRot += (window_mouse_get_y() - lastMouseY);
    yRot += (window_mouse_get_x() - lastMouseX);
    
    xRot = clamp(xRot, -90, 90);
    
    //Keyboard Input (Move)
    var AxisWS = (keyboard_check(ord("W")) - keyboard_check(ord("S")));
    var fX  = sqrt(power(91, 2) - power(xRot, 2));
    
    yFrom += ((dcos(yRot+90) * dcos(xRot)) * AxisWS) * camSpeed;
    xFrom += ((dsin(yRot+90) * dcos(xRot)) * AxisWS) * camSpeed;
    zFrom += (dsin(xRot) * AxisWS) * camSpeed;
    
    lastMouseX = window_mouse_get_x();
    lastMouseY = window_mouse_get_y();
    
    if(lastMouseX &lt; 0)
    {
        window_mouse_set(room_width, lastMouseY);
        lastMouseX = room_width;
    }else
    if(lastMouseX &gt; room_width)
    {
        window_mouse_set(0, lastMouseY);
        lastMouseX = 0;
    }
    
    if(lastMouseY &lt; 0)
    {
        window_mouse_set(lastMouseX, room_height);
        lastMouseY = room_height;
    }else
    if(lastMouseY &gt; room_height)
    {
        window_mouse_set(lastMouseX, 0);
        lastMouseY = 0;
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="10">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Load Map Data

if(dataReady == true)
{
    MAP1Free(map1Data);    
    RTMDFree(rtmdData);
    RTIMFree(rtimData);
    
    background_delete(psxVRAM);
    
    FreeMapVBs(); 
}

var MAP = lMapFiles[| mapLoadID];

show_debug_message("Loading " + MAP[0]+"...");

map1Data = MAP1Load(FDAT, MAP[1]);
map2Data = MAP2Load(FDAT, MAP[2]);
map3Data = noone;
rtmdData = RTMDLoad(RTMD, MAP[4]);
rtimData = RTIMLoad(RTIM, MAP[5]);

show_debug_message("Building Map VBs...");
BuildMapVBs();

show_debug_message("Building Map VRAM...");
BuildMapVRAM();

show_debug_message("Done!");

MapName = numPad(mapLoadID, "0", 2) + " " + MAP[0];

dataReady = true;
renderMiniMap = true;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="64">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Render MiniMap

//Recreate MiniMap surface if it's missing
if(!surface_exists(minimapSurf))
{
    renderMiniMap = true;
    
    minimapSurf = surface_create(minimapSize, minimapSize);
    mapviewSurf = surface_create(mapviewW, mapviewH);
}

if(dataReady == true &amp;&amp; renderMiniMap == true)
{
    //Get Tilemap from map
    var tmap = map1Data[0];
    
    //Draw to surface
    surface_set_target(minimapSurf);
    
    draw_clear(c_black);
    for(var yy = 0; yy &lt; 80; yy++)
    {
        for(var xx = 0; xx &lt; 80; xx++)
        {
            //Get tile from TMap
            var tile = tmap[xx, yy];
            
            var G = ((tile[1] / 4) * 3) + (tile[3] / 4);
            var B = ((tile[6] / 4) * 3) + (tile[8] / 4);
                
            draw_point_colour(xx, yy, make_colour_rgb(0, G, B));
        }
    }
    
    surface_reset_target();
    
    renderMiniMap = false;
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Render UI

//Draw BG
draw_clear($604315);

//Draw Frames (fill)
draw_set_colour($76521A);
draw_rectangle(2, 2, 262, 538, false); 

//Draw frames (outline)
draw_set_colour($8C6121);
draw_rectangle(2, 2, 262, 538, true);

//Draw Scroll Bar
var ScrollActive = ds_list_size(lMapFiles) &gt; scrollMapVLim;
var ScrollPos = 0;

if(ScrollActive &amp;&amp; !fullscreen)
{
    //Scroll Fill
    draw_set_colour($604315);
    draw_rectangle(242, 4, 262, 278, false);
    
    //Draw Scrubber
    ScrollPos = (4 + 16) + scrollScrubVPos;
    
    draw_set_colour($E2AD5D);
    draw_rectangle(243, ScrollPos-16, 261, ScrollPos+16, false);
    draw_set_colour($724F1B);
    draw_rectangle(243, ScrollPos-16, 261, ScrollPos+16, true);
        
    //Scroll Frame
    draw_set_colour($8D611F);
    draw_rectangle(242, 4, 262, 278, true);
    

}else
if(!fullscreen) {
    //Scroll Fill (Off)
    draw_set_colour($503E2C);
    draw_rectangle(242, 4, 262, 278, false);

    //Draw Scrubber
    ScrollPos = (4 + 16) + scrollScrubVPos;
    
    draw_set_colour($736556);
    draw_rectangle(243, ScrollPos-16, 261, ScrollPos+16, false);
    draw_set_colour($2A2017);
    draw_rectangle(243, ScrollPos-16, 261, ScrollPos+16, true);    
        
    //Scroll Frame (Off)
    draw_set_colour($3D2F21);
    draw_rectangle(242, 4, 262, 278, true);    
}

//Always clamp scrollMapVNum to avoid array access errors
scrollMapVNum = clamp(scrollMapVOff + scrollMapVLim, 0, ds_list_size(lMapFiles)); 

//Draw Map Files
draw_set_colour($FAFAFA);
var DXP, DYP, DWS, DHS;

for(var i = scrollMapVOff; i &lt; scrollMapVNum; ++i)
{
    var map = lMapFiles[| i];
    
    //Calculate Positions
    DXP = 2;
    DYP = 4 + (16 * (i - scrollMapVOff));
    DWS = DXP + 238;
    DHS = DYP + 16;
    
    //Draw with a fill, if selected or hovered over
    if(point_in_rectangle(mouse_x, mouse_y, DXP, DYP, DWS, DHS - 1) || i == mapLoadID)
    {
        draw_set_colour($F1D6AE);
        draw_rectangle(DXP, DYP, DWS, DHS, false);
        
        draw_set_colour($080808);
        draw_text(DXP + 2, DYP, map[0]);
        
        draw_set_colour($FAFAFA);
        
        continue;
    }    
    
    draw_text(DXP + 2, DYP, map[0]);
}

if(!fullscreen)
{
    //Draw MapView to screen
    draw_surface(mapviewSurf, 264, 2);
    
    draw_set_colour($DB9834);
    draw_rectangle(264, 2, 264 + mapviewW, 2 + mapviewH, true);
    
    //Draw minimap to screen
    draw_surface_stretched(minimapSurf, 4, 280, 256, 256);

    draw_set_colour($DB9834);
    draw_rectangle(4, 280, 260, 536, true);

    var pxmm = clamp(yFrom / $28000, 0, 1) * 256;
    var pymm = clamp(xFrom / $28000, 0, 1) * 256;

    //Draw Minimap Pos
    draw_set_colour(c_yellow);
    draw_circle(4 + pxmm, 280 + pymm, 4, false);
    
    draw_set_colour(c_white);
    draw_text(266, 524, "Press F to enter fullscreen");
}else
{
    draw_set_colour(c_black);
    draw_rectangle(0, 0, room_width, room_height, false);
    
    draw_surface_stretched(mapviewSurf, 0, 0, room_width, room_height);
    
    //Draw minimap to screen
    draw_surface_stretched(minimapSurf, 8, 540-136, 128, 128);

    draw_set_colour($DB9834);
    draw_rectangle(8, 540-136, 136, 540-8, true);

    var pxmm = clamp(yFrom / $28000, 0, 1) * 128;
    var pymm = clamp(xFrom / $28000, 0, 1) * 128;

    //Draw Minimap Pos
    draw_set_colour(c_yellow);
    draw_circle(8 + pxmm, (540-136) + pymm, 2, false);
    
    draw_set_colour(c_white);
    draw_text(2, 524, "Press F to exit fullscreen");
}

draw_text(266, 2, "FPS: " + string(fps_real));

if(keyboard_check(ord("V")))
{
    draw_background_stretched(psxVRAM, 0, 0, 512, 64);
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Draw Map View (RTMD)

d3d_start();
d3d_set_culling(false);

if(!surface_exists(mapviewSurf))
    mapviewSurf = surface_create(mapviewW, mapviewH);

if(dataReady)
{
    var tmap = map1Data[0];
    
    //Set Draw Target
    surface_set_target(mapviewSurf);
    draw_clear(c_black);
    
    //Camera Projection
    var fX  = sqrt(power(91, 2) - power(xRot, 2));
    var xTo = xFrom + lengthdir_x(fX, yRot);
    var yTo = yFrom + lengthdir_y(fX, yRot);
    var zTo = zFrom + xRot;

    d3d_set_projection_ext(yFrom, zFrom, xFrom, yTo, zTo, xTo, 0, -1, 0, 60, mapviewW / mapviewH, 0.1, $28000);
  
    //Player Tile Position
    var camX = xFrom &gt;&gt; $B;
    var camY = yFrom &gt;&gt; $B;
    
    draw_set_colour(c_white);  
    
    shader_set(shdStatic);
    shader_set_uniform_f(shader_get_uniform(shdStatic, "uAlpha"), 1.0);
    
    //
    // Draw Objects
    //
    var ObjectInstance = map2Data[2];
    for(var i = 0; i &lt; ds_list_size(ObjectInstance); ++i)
    {
        var OI = ObjectInstance[| i];
        
        if(point_distance(OI[1], OI[2], camX, camY) &gt; 15 &amp;&amp; (OI[4] != 247) &amp;&amp; (OI[4] != 248))
            continue;   
            
        var TI = tmap[OI[2], OI[1]];
        var PY;
              
        PY = TI[1 + (5 * OI[0])] * -$80;
        
        //Switch to handle different object types
        if(GameVersion &lt; KFVersion.KFIIIJpRev0)
        {  
            switch(OI[4])
            {
            case 248:
               draw_set_blend_mode(bm_add);                
            case 247: 
                d3d_transform_add_rotation_y(OI[5]);
                d3d_transform_add_scaling(-2, 2, -2); //flip offending models
                d3d_transform_add_translation(yFrom, zFrom, xFrom);           
                
                d3d_set_zwriteenable(false);
                    MODraw($80 + OI[4]);      
                d3d_set_zwriteenable(true);   
                
                draw_set_blend_mode(bm_normal);  
            break;
            
            default:
                d3d_transform_add_rotation_y(OI[5]);
                d3d_transform_add_scaling(-1, 1, 1); //flip offending models
                d3d_transform_add_translation(((2048 * OI[2]) + OI[7]) - 1024, PY + OI[8], ((2048 * OI[1]) - OI[6]) + 1024);            
                MODraw($80 + OI[4]);  
                break;
            }
            d3d_transform_set_identity();
        }else
        {                
            d3d_transform_add_rotation_y(OI[5]);
            d3d_transform_add_scaling(-1, 1, 1); //flip offending models
            d3d_transform_add_translation(((2048 * OI[2]) + OI[7]) - 1024, PY + OI[8], ((2048 * OI[1]) - OI[6]) + 1024);            
                MODraw($80 + OI[4]); 
            d3d_transform_set_identity();                        
        }
        
        //Draw Object IDs
        if(drawObjIDs)
        {
            shader_reset();
            
            var XPos = ((2048 * OI[2]) + OI[7]);
            var YPos = ((2048 * OI[1]) - OI[6]);
            var ZPos = (PY + OI[8]) - 2048;
        
            draw_set_blend_mode(bm_add);
            draw_set_alpha_test(true);
            draw_set_alpha_test_ref_value(0.1);
            
            //Calculate Rotation            
            d3d_transform_add_rotation_y(270 - point_direction(XPos, YPos, yFrom, xFrom));
            d3d_transform_add_scaling(32, 32, 32); //Scale Text
            d3d_transform_add_translation(XPos - 1024, ZPos, YPos + 1024);   
            
                draw_set_halign(fa_center);        
                draw_text(0, 0, "ID: " + string($80 + OI[4]));
                draw_set_halign(fa_left);
                
            d3d_transform_set_identity();  
            
            draw_set_blend_mode(bm_normal); 
            draw_set_alpha_test(false);
            draw_set_alpha_test_ref_value(1);    
            
            shader_set(shdStatic);
            shader_set_uniform_f(shader_get_uniform(shdStatic, "uAlpha"), 1.0);
        } 
    }
     
    //
    // Draw Entities
    //
    var EntityClass = map2Data[0];
    var EntityInstance = map2Data[1];
    
    for(var i = 0; i &lt; ds_list_size(EntityInstance); ++i)
    {
        var EI = EntityInstance[| i];                
        var EC = EntityClass[| EI[1]];

        if(EC &gt;= $80)
            continue;
            
        if(point_distance(EI[3], EI[4], camX, camY) &gt; 15 &amp;&amp; OI[4])
            continue;  
                         
        //Calculate Y
        var TI = tmap[EI[4], EI[3]];
        var PY;
              
        PY = TI[1 + (5 * EI[7])] * -$80;
                

        d3d_transform_add_rotation_y(EI[8]);
        d3d_transform_add_scaling(1, 1, 1); //flip offending models
        d3d_transform_add_translation(((2048 * EI[4]) + EI[10]) - 1024, PY + EI[11], ((2048 * EI[3]) - EI[9]) + 1024);    
               
            MODraw(EC);  
        
        d3d_transform_set_identity();       
    }      
    
    //
    //Draw Chunks (Opaque)
    //
    draw_set_colour(c_white);
    var xPos, yPos;
    for(var yy = 0; yy &lt; 8; yy++)
    {
        yPos = 20480 * yy;
        for(var xx = 0; xx &lt; 8; xx++)
        {           
            if(chunkedMapDataO[# xx, yy] == -1)
                continue;
                
            xPos = 20480 * xx;
            d3d_transform_add_translation(xPos, 0, yPos);
                vertex_submit(chunkedMapDataO[# xx, yy], pr_trianglelist, psxVRAMTex);
            d3d_transform_set_identity();   
        }
    }    
    
    shader_set_uniform_f(shader_get_uniform(shdStatic, "uAlpha"), 0.5);
    //
    //Draw Chunks (Transparent)
    //
    var xPos, yPos;
    for(var yy = 0; yy &lt; 8; yy++)
    {
        yPos = 20480 * yy;
        for(var xx = 0; xx &lt; 8; xx++)
        {
            if(chunkedMapDataT[# xx, yy] == -1)
                continue;
        
            xPos = 20480 * xx;
            d3d_transform_add_translation(xPos, 0, yPos);
                vertex_submit(chunkedMapDataT[# xx, yy], pr_trianglelist, psxVRAMTex);
            d3d_transform_set_identity();    
        }
    }

    shader_reset();      
         
    //
    // Draw and Handle Triggers
    //
    
    var TriggerInstance = map2Data[4];
       
    for(var i = 0; i &lt; ds_list_size(TriggerInstance); ++i)
    {       
        var OI = TriggerInstance[| i]; 

        var TI = tmap[OI[2], OI[1]];
        var PY;
                
        PY = TI[1 + (5 * OI[0])] * -$80;
        
        d3d_transform_add_scaling(OI[11], 1, -OI[12]);
        d3d_transform_add_translation((2048 * OI[2]) - 1024, PY, (2048 * OI[1]) + 1024);
        d3d_draw_wirecube(0, 0, 0);   
        d3d_transform_set_identity();
        
        //Calculate Trigger Points
        var TX1 = (2048 * OI[2])-1024;
        var TY1 = (2048 * OI[1])+1024;       
        var TX2 = (2048 * (OI[2]+OI[11]))-1024;
        var TY2 = (2048 * (OI[1]-OI[12]))+1024;        
             
        //Handle Trigger
        var InT = point_in_rectangle(yFrom, xFrom, TX1, TY2, TX2, TY1);
        
        //Entered
        if(OI[@ 20] == false &amp;&amp; InT == true)
        {
            show_debug_message("Entered Trigger: " + string(i));
            
            //Load RTIM specified by flag...
            if(OI[13] == mapLoadID)
            {
                surface_reset_target();
                d3d_end();
                
                exit;
            }
            
            if(OI[13] != $FF)
            {
                d3d_end();
                d3d_set_projection_ortho(0, 0, 4096, 512, 0);
                
                mapLoadID = OI[13];
                
                xFrom = (2048 * (79-OI[6]));
                yFrom = (2048 * OI[7]);
                
                event_perform(ev_other, ev_user0);
                surface_reset_target();
                
                exit;
            }else
            if(OI[15] != $FF)
            {   
                d3d_end();
                d3d_set_projection_ortho(0, 0, 4096, 512, 90);
                     
                if(rtimFromTrigger != noone)
                {
                    RTIMFree(rtimFromTrigger);
                }          
                rtimFromTrigger = RTIMLoad(RTIM, OI[15]);
            
                //Rebuild VRAM
                var tempSurf = surface_create(4096, 512);              
                                
                surface_set_target(tempSurf);
                d3d_set_projection_ortho(0, 0, 4096, 512, 0);
                draw_clear(c_black);
                
                draw_background(psxVRAM, 0, 0);
                
                for(var i = 0; i &lt; ds_list_size(rtimFromTrigger); ++i)
                {
                    var BG = rtimFromTrigger[| i];    
                    draw_background(BG[0], BG[1] &lt;&lt; 2, BG[2]);
                }
                
                surface_reset_target();
                
                //Copy VRAM to texture
                background_delete(psxVRAM);
                
                psxVRAM = background_create_from_surface(tempSurf, 0, 0, 4096, 512, false, false);
                psxVRAMTex = background_get_texture(psxVRAM);
                
                surface_free(tempSurf);     
                
                d3d_start();     
            }
            
            show_debug_message("        MAP  To Load: " + dec_to_hex(OI[13]));
            show_debug_message("        RTMD To Load: " + dec_to_hex(OI[14]));
            show_debug_message("        RTIM To Load: " + dec_to_hex(OI[15]));
            show_debug_message("        SEQ  To Load: " + dec_to_hex(OI[16]));
            show_debug_message("        VAB  To Load: " + dec_to_hex(OI[17]));
        }
        
        //Exited... We don't need this?
        /*
        if(triggerState[i] == true &amp;&amp; InT == false)
        {
            show_debug_message("Exited Trigger: " + string(i));
        }*/
        
        OI[@ 20] = InT;
    }
     
    draw_set_alpha(1.0);
    draw_set_colour(c_black); 
       
    surface_reset_target();
}

d3d_end();
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
